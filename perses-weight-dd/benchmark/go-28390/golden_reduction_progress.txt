======================Reduction starts======================

The spar tree is the following.
sourceFile {id=1}
|___packageClause {id=2,slot_type=packageClause}
|   |___Token:package {id=495,slot_type=PACKAGE}
|   |___Token:main {id=496,slot_type=IDENTIFIER}
|___Token:; {id=494,slot_type=eos}
|___(*) {id=4,slot_type=kleene_star__sourceFile_2}
|   |___sourceFile_1 {id=479,slot_type=sourceFile_1}
|       |___importDecl {id=480,slot_type=importDecl}
|       |   |___Token:import {id=483,slot_type=IMPORT}
|       |   |___Token:( {id=484,slot_type=L_PAREN}
|       |   |___(*) {id=485,slot_type=kleene_star__importDecl_2}
|       |   |   |___importDecl_1 {id=487,slot_type=importDecl_1}
|       |   |       |___Token:"fmt" {id=493,slot_type=importSpec}
|       |   |       |___Token:; {id=490,slot_type=eos}
|       |   |___Token:) {id=486,slot_type=R_PAREN}
|       |___Token:; {id=482,slot_type=eos}
|___(*) {id=5,slot_type=kleene_star__sourceFile_4}
    |___sourceFile_3 {id=6,slot_type=sourceFile_3}
    |   |___typeDecl {id=433,slot_type=declaration}
    |   |   |___Token:type {id=434,slot_type=TYPE}
    |   |   |___typeSpec {id=435,slot_type=typeSpec}
    |   |       |___Token:A {id=436,slot_type=IDENTIFIER}
    |   |       |___structType {id=438,slot_type=type_}
    |   |           |___Token:struct {id=439,slot_type=STRUCT}
    |   |           |___Token:{ {id=440,slot_type=L_CURLY}
    |   |           |___(*) {id=441,slot_type=kleene_star__structType_2}
    |   |           |   |___structType_1 {id=443,slot_type=structType_1}
    |   |           |   |   |___fieldDecl {id=471,slot_type=fieldDecl}
    |   |           |   |   |   |___Token:K {id=478,slot_type=identifierList}
    |   |           |   |   |   |___Token:int {id=477,slot_type=type_}
    |   |           |   |   |___Token:; {id=473,slot_type=eos}
    |   |           |   |___structType_1 {id=444,slot_type=structType_1}
    |   |           |   |   |___fieldDecl {id=463,slot_type=fieldDecl}
    |   |           |   |   |   |___Token:S {id=470,slot_type=identifierList}
    |   |           |   |   |   |___Token:string {id=469,slot_type=type_}
    |   |           |   |   |___Token:; {id=465,slot_type=eos}
    |   |           |   |___structType_1 {id=445,slot_type=structType_1}
    |   |           |       |___fieldDecl {id=446,slot_type=fieldDecl}
    |   |           |       |   |___Token:M {id=462,slot_type=identifierList}
    |   |           |       |   |___mapType {id=451,slot_type=type_}
    |   |           |       |       |___Token:map {id=452,slot_type=MAP}
    |   |           |       |       |___Token:[ {id=453,slot_type=L_BRACKET}
    |   |           |       |       |___Token:string {id=461,slot_type=type_}
    |   |           |       |       |___Token:] {id=455,slot_type=R_BRACKET}
    |   |           |       |       |___Token:string {id=459,slot_type=elementType}
    |   |           |       |___Token:; {id=448,slot_type=eos}
    |   |           |___Token:} {id=442,slot_type=R_CURLY}
    |   |___Token:; {id=432,slot_type=eos}
    |___sourceFile_3 {id=7,slot_type=sourceFile_3}
    |   |___functionDecl {id=237,slot_type=functionDecl}
    |   |   |___Token:func {id=240,slot_type=FUNC}
    |   |   |___Token:newA {id=241,slot_type=IDENTIFIER}
    |   |   |___signature {id=242,slot_type=signature}
    |   |   |   |___parameters {id=394,slot_type=parameters}
    |   |   |   |   |___Token:( {id=409,slot_type=L_PAREN}
    |   |   |   |   |___(?) {id=410,slot_type=optional__parameters_5}
    |   |   |   |   |   |___parameters_4 {id=412,slot_type=parameters_4}
    |   |   |   |   |       |___parameterDecl {id=413,slot_type=parameterDecl}
    |   |   |   |   |       |   |___(?) {id=424,slot_type=optional__parameterDecl_1}
    |   |   |   |   |       |   |   |___Token:k {id=429,slot_type=identifierList}
    |   |   |   |   |       |   |___Token:int {id=427,slot_type=type_}
    |   |   |   |   |       |___(*) {id=414,slot_type=kleene_star__parameters_2}
    |   |   |   |   |           |___parameters_1 {id=415,slot_type=parameters_1}
    |   |   |   |   |               |___Token:, {id=416,slot_type=COMMA}
    |   |   |   |   |               |___parameterDecl {id=417,slot_type=parameterDecl}
    |   |   |   |   |                   |___(?) {id=418,slot_type=optional__parameterDecl_1}
    |   |   |   |   |                   |   |___Token:s {id=423,slot_type=identifierList}
    |   |   |   |   |                   |___Token:string {id=421,slot_type=type_}
    |   |   |   |   |___Token:) {id=411,slot_type=R_PAREN}
    |   |   |   |___(?) {id=395,slot_type=optional__signature_1}
    |   |   |       |___parameters {id=397,slot_type=result}
    |   |   |           |___Token:( {id=398,slot_type=L_PAREN}
    |   |   |           |___(?) {id=399,slot_type=optional__parameters_5}
    |   |   |           |   |___parameterDecl {id=402,slot_type=parameters_4}
    |   |   |           |       |___(?) {id=403,slot_type=optional__parameterDecl_1}
    |   |   |           |       |   |___Token:a {id=408,slot_type=identifierList}
    |   |   |           |       |___Token:A {id=406,slot_type=type_}
    |   |   |           |___Token:) {id=400,slot_type=R_PAREN}
    |   |   |___(?) {id=243,slot_type=optional__functionDecl_1}
    |   |       |___block {id=244,slot_type=block}
    |   |           |___Token:{ {id=245,slot_type=L_CURLY}
    |   |           |___(?) {id=246,slot_type=optional__block_1}
    |   |           |   |___(+) {id=249,slot_type=statementList}
    |   |           |       |___statementList_1 {id=250,slot_type=statementList_1}
    |   |           |       |   |___assignment {id=372,slot_type=realStatement}
    |   |           |       |   |   |___methodExpr {id=387,slot_type=expressionList}
    |   |           |       |   |   |   |___Token:a {id=393,slot_type=elementType}
    |   |           |       |   |   |   |___Token:. {id=389,slot_type=DOT}
    |   |           |       |   |   |   |___Token:K {id=390,slot_type=IDENTIFIER}
    |   |           |       |   |   |___Token:= {id=382,slot_type=assign_op}
    |   |           |       |   |   |___Token:k {id=381,slot_type=expressionList}
    |   |           |       |   |___Token:; {id=370,slot_type=eos}
    |   |           |       |___statementList_1 {id=251,slot_type=statementList_1}
    |   |           |       |   |___assignment {id=346,slot_type=realStatement}
    |   |           |       |   |   |___methodExpr {id=361,slot_type=expressionList}
    |   |           |       |   |   |   |___Token:a {id=367,slot_type=elementType}
    |   |           |       |   |   |   |___Token:. {id=363,slot_type=DOT}
    |   |           |       |   |   |   |___Token:S {id=364,slot_type=IDENTIFIER}
    |   |           |       |   |   |___Token:= {id=356,slot_type=assign_op}
    |   |           |       |   |   |___Token:s {id=355,slot_type=expressionList}
    |   |           |       |   |___Token:; {id=344,slot_type=eos}
    |   |           |       |___statementList_1 {id=252,slot_type=statementList_1}
    |   |           |       |   |___assignment {id=301,slot_type=realStatement}
    |   |           |       |   |   |___methodExpr {id=335,slot_type=expressionList}
    |   |           |       |   |   |   |___Token:a {id=341,slot_type=elementType}
    |   |           |       |   |   |   |___Token:. {id=337,slot_type=DOT}
    |   |           |       |   |   |   |___Token:M {id=338,slot_type=IDENTIFIER}
    |   |           |       |   |   |___Token:= {id=330,slot_type=assign_op}
    |   |           |       |   |   |___primaryExpr {id=307,slot_type=expressionList}
    |   |           |       |   |       |___Token:make {id=329,slot_type=primaryExpr_3}
    |   |           |       |   |       |___(*) {id=309,slot_type=kleene_star__primaryExpr_1}
    |   |           |       |   |           |___arguments {id=311,slot_type=primaryExpr_2}
    |   |           |       |   |               |___Token:( {id=312,slot_type=L_PAREN}
    |   |           |       |   |               |___(?) {id=313,slot_type=optional__arguments_6}
    |   |           |       |   |               |   |___mapType {id=317,slot_type=arguments_5}
    |   |           |       |   |               |       |___Token:map {id=318,slot_type=MAP}
    |   |           |       |   |               |       |___Token:[ {id=319,slot_type=L_BRACKET}
    |   |           |       |   |               |       |___Token:string {id=327,slot_type=type_}
    |   |           |       |   |               |       |___Token:] {id=321,slot_type=R_BRACKET}
    |   |           |       |   |               |       |___Token:string {id=325,slot_type=elementType}
    |   |           |       |   |               |___Token:) {id=314,slot_type=R_PAREN}
    |   |           |       |   |___Token:; {id=299,slot_type=eos}
    |   |           |       |___statementList_1 {id=253,slot_type=statementList_1}
    |   |           |       |   |___assignment {id=264,slot_type=realStatement}
    |   |           |       |   |   |___primaryExpr {id=277,slot_type=expressionList}
    |   |           |       |   |   |   |___methodExpr {id=290,slot_type=primaryExpr_3}
    |   |           |       |   |   |   |   |___Token:a {id=296,slot_type=elementType}
    |   |           |       |   |   |   |   |___Token:. {id=292,slot_type=DOT}
    |   |           |       |   |   |   |   |___Token:M {id=293,slot_type=IDENTIFIER}
    |   |           |       |   |   |   |___(*) {id=279,slot_type=kleene_star__primaryExpr_1}
    |   |           |       |   |   |       |___index {id=281,slot_type=primaryExpr_2}
    |   |           |       |   |   |           |___Token:[ {id=282,slot_type=L_BRACKET}
    |   |           |       |   |   |           |___Token:s {id=289,slot_type=expression}
    |   |           |       |   |   |           |___Token:] {id=284,slot_type=R_BRACKET}
    |   |           |       |   |   |___Token:= {id=274,slot_type=assign_op}
    |   |           |       |   |   |___Token:s {id=273,slot_type=expressionList}
    |   |           |       |   |___Token:; {id=262,slot_type=eos}
    |   |           |       |___statementList_1 {id=254,slot_type=statementList_1}
    |   |           |           |___Token:return {id=259,slot_type=realStatement}
    |   |           |           |___Token:; {id=257,slot_type=eos}
    |   |           |___Token:} {id=247,slot_type=R_CURLY}
    |   |___Token:; {id=239,slot_type=eos}
    |___sourceFile_3 {id=8,slot_type=sourceFile_3}
    |   |___functionDecl {id=153,slot_type=functionDecl}
    |   |   |___Token:func {id=156,slot_type=FUNC}
    |   |   |___Token:proxy {id=157,slot_type=IDENTIFIER}
    |   |   |___signature {id=158,slot_type=signature}
    |   |   |   |___parameters {id=210,slot_type=parameters}
    |   |   |   |   |___Token:( {id=235,slot_type=L_PAREN}
    |   |   |   |   |___Token:) {id=236,slot_type=R_PAREN}
    |   |   |   |___(?) {id=211,slot_type=optional__signature_1}
    |   |   |       |___parameters {id=213,slot_type=result}
    |   |   |           |___Token:( {id=214,slot_type=L_PAREN}
    |   |   |           |___(?) {id=215,slot_type=optional__parameters_5}
    |   |   |           |   |___parameters_4 {id=217,slot_type=parameters_4}
    |   |   |           |       |___parameterDecl {id=218,slot_type=parameterDecl}
    |   |   |           |       |   |___(?) {id=229,slot_type=optional__parameterDecl_1}
    |   |   |           |       |   |   |___Token:x {id=234,slot_type=identifierList}
    |   |   |           |       |   |___Token:int {id=232,slot_type=type_}
    |   |   |           |       |___(*) {id=219,slot_type=kleene_star__parameters_2}
    |   |   |           |           |___parameters_1 {id=220,slot_type=parameters_1}
    |   |   |           |               |___Token:, {id=221,slot_type=COMMA}
    |   |   |           |               |___parameterDecl {id=222,slot_type=parameterDecl}
    |   |   |           |                   |___(?) {id=223,slot_type=optional__parameterDecl_1}
    |   |   |           |                   |   |___Token:a {id=228,slot_type=identifierList}
    |   |   |           |                   |___Token:A {id=226,slot_type=type_}
    |   |   |           |___Token:) {id=216,slot_type=R_PAREN}
    |   |   |___(?) {id=159,slot_type=optional__functionDecl_1}
    |   |       |___block {id=160,slot_type=block}
    |   |           |___Token:{ {id=161,slot_type=L_CURLY}
    |   |           |___(?) {id=162,slot_type=optional__block_1}
    |   |           |   |___(+) {id=165,slot_type=statementList}
    |   |           |       |___statementList_1 {id=166,slot_type=statementList_1}
    |   |           |           |___returnStmt {id=170,slot_type=realStatement}
    |   |           |           |   |___Token:return {id=171,slot_type=RETURN}
    |   |           |           |   |___(?) {id=172,slot_type=optional__returnStmt_1}
    |   |           |           |       |___expressionList {id=173,slot_type=expressionList}
    |   |           |           |           |___Token:1 {id=209,slot_type=expression}
    |   |           |           |           |___(*) {id=175,slot_type=kleene_star__expressionList_2}
    |   |           |           |               |___expressionList_1 {id=176,slot_type=expressionList_1}
    |   |           |           |                   |___Token:, {id=177,slot_type=COMMA}
    |   |           |           |                   |___primaryExpr {id=180,slot_type=expression}
    |   |           |           |                       |___Token:newA {id=205,slot_type=primaryExpr_3}
    |   |           |           |                       |___(*) {id=182,slot_type=kleene_star__primaryExpr_1}
    |   |           |           |                           |___arguments {id=184,slot_type=primaryExpr_2}
    |   |           |           |                               |___Token:( {id=185,slot_type=L_PAREN}
    |   |           |           |                               |___(?) {id=186,slot_type=optional__arguments_6}
    |   |           |           |                               |   |___expressionList {id=189,slot_type=arguments_5}
    |   |           |           |                               |       |___Token:2 {id=203,slot_type=expression}
    |   |           |           |                               |       |___(*) {id=191,slot_type=kleene_star__expressionList_2}
    |   |           |           |                               |           |___expressionList_1 {id=192,slot_type=expressionList_1}
    |   |           |           |                               |               |___Token:, {id=193,slot_type=COMMA}
    |   |           |           |                               |               |___Token:"3" {id=199,slot_type=expression}
    |   |           |           |                               |___Token:) {id=187,slot_type=R_PAREN}
    |   |           |           |___Token:; {id=169,slot_type=eos}
    |   |           |___Token:} {id=163,slot_type=R_CURLY}
    |   |___Token:; {id=155,slot_type=eos}
    |___sourceFile_3 {id=9,slot_type=sourceFile_3}
    |   |___functionDecl {id=54,slot_type=functionDecl}
    |   |   |___Token:func {id=57,slot_type=FUNC}
    |   |   |___Token:consume {id=58,slot_type=IDENTIFIER}
    |   |   |___parameters {id=129,slot_type=signature}
    |   |   |   |___Token:( {id=130,slot_type=L_PAREN}
    |   |   |   |___(?) {id=131,slot_type=optional__parameters_5}
    |   |   |   |   |___parameters_4 {id=133,slot_type=parameters_4}
    |   |   |   |       |___parameterDecl {id=134,slot_type=parameterDecl}
    |   |   |   |       |   |___(?) {id=147,slot_type=optional__parameterDecl_1}
    |   |   |   |       |   |   |___Token:x {id=152,slot_type=identifierList}
    |   |   |   |       |   |___Token:int {id=150,slot_type=type_}
    |   |   |   |       |___(*) {id=135,slot_type=kleene_star__parameters_2}
    |   |   |   |           |___parameters_1 {id=136,slot_type=parameters_1}
    |   |   |   |               |___Token:, {id=137,slot_type=COMMA}
    |   |   |   |               |___parameterDecl {id=138,slot_type=parameterDecl}
    |   |   |   |                   |___(?) {id=139,slot_type=optional__parameterDecl_1}
    |   |   |   |                   |   |___Token:a {id=146,slot_type=identifierList}
    |   |   |   |                   |___interfaceType {id=141,slot_type=type_}
    |   |   |   |                       |___Token:interface {id=142,slot_type=INTERFACE}
    |   |   |   |                       |___Token:{ {id=143,slot_type=L_CURLY}
    |   |   |   |                       |___Token:} {id=144,slot_type=R_CURLY}
    |   |   |   |___Token:) {id=132,slot_type=R_PAREN}
    |   |   |___(?) {id=60,slot_type=optional__functionDecl_1}
    |   |       |___block {id=61,slot_type=block}
    |   |           |___Token:{ {id=62,slot_type=L_CURLY}
    |   |           |___(?) {id=63,slot_type=optional__block_1}
    |   |           |   |___(+) {id=66,slot_type=statementList}
    |   |           |       |___statementList_1 {id=67,slot_type=statementList_1}
    |   |           |       |   |___primaryExpr {id=106,slot_type=realStatement}
    |   |           |       |   |   |___methodExpr {id=122,slot_type=primaryExpr_3}
    |   |           |       |   |   |   |___Token:fmt {id=128,slot_type=elementType}
    |   |           |       |   |   |   |___Token:. {id=124,slot_type=DOT}
    |   |           |       |   |   |   |___Token:Println {id=125,slot_type=IDENTIFIER}
    |   |           |       |   |   |___(*) {id=108,slot_type=kleene_star__primaryExpr_1}
    |   |           |       |   |       |___arguments {id=110,slot_type=primaryExpr_2}
    |   |           |       |   |           |___Token:( {id=111,slot_type=L_PAREN}
    |   |           |       |   |           |___(?) {id=112,slot_type=optional__arguments_6}
    |   |           |       |   |           |   |___Token:x {id=121,slot_type=arguments_5}
    |   |           |       |   |           |___Token:) {id=113,slot_type=R_PAREN}
    |   |           |       |   |___Token:; {id=101,slot_type=eos}
    |   |           |       |___statementList_1 {id=68,slot_type=statementList_1}
    |   |           |           |___primaryExpr {id=76,slot_type=realStatement}
    |   |           |           |   |___methodExpr {id=92,slot_type=primaryExpr_3}
    |   |           |           |   |   |___Token:fmt {id=98,slot_type=elementType}
    |   |           |           |   |   |___Token:. {id=94,slot_type=DOT}
    |   |           |           |   |   |___Token:Println {id=95,slot_type=IDENTIFIER}
    |   |           |           |   |___(*) {id=78,slot_type=kleene_star__primaryExpr_1}
    |   |           |           |       |___arguments {id=80,slot_type=primaryExpr_2}
    |   |           |           |           |___Token:( {id=81,slot_type=L_PAREN}
    |   |           |           |           |___(?) {id=82,slot_type=optional__arguments_6}
    |   |           |           |           |   |___Token:a {id=91,slot_type=arguments_5}
    |   |           |           |           |___Token:) {id=83,slot_type=R_PAREN}
    |   |           |           |___Token:; {id=71,slot_type=eos}
    |   |           |___Token:} {id=64,slot_type=R_CURLY}
    |   |___Token:; {id=56,slot_type=eos}
    |___sourceFile_3 {id=10,slot_type=sourceFile_3}
        |___functionDecl {id=11,slot_type=functionDecl}
        |   |___Token:func {id=14,slot_type=FUNC}
        |   |___Token:main {id=15,slot_type=IDENTIFIER}
        |   |___parameters {id=51,slot_type=signature}
        |   |   |___Token:( {id=52,slot_type=L_PAREN}
        |   |   |___Token:) {id=53,slot_type=R_PAREN}
        |   |___(?) {id=17,slot_type=optional__functionDecl_1}
        |       |___block {id=18,slot_type=block}
        |           |___Token:{ {id=19,slot_type=L_CURLY}
        |           |___(?) {id=20,slot_type=optional__block_1}
        |           |   |___(+) {id=23,slot_type=statementList}
        |           |       |___statementList_1 {id=24,slot_type=statementList_1}
        |           |           |___conversion {id=34,slot_type=realStatement}
        |           |           |   |___Token:consume {id=50,slot_type=type_}
        |           |           |   |___Token:( {id=36,slot_type=L_PAREN}
        |           |           |   |___primaryExpr {id=40,slot_type=expression}
        |           |           |   |   |___Token:proxy {id=48,slot_type=primaryExpr_3}
        |           |           |   |   |___(*) {id=42,slot_type=kleene_star__primaryExpr_1}
        |           |           |   |       |___arguments {id=44,slot_type=primaryExpr_2}
        |           |           |   |           |___Token:( {id=45,slot_type=L_PAREN}
        |           |           |   |           |___Token:) {id=46,slot_type=R_PAREN}
        |           |           |   |___Token:) {id=38,slot_type=R_PAREN}
        |           |           |___Token:; {id=27,slot_type=eos}
        |           |___Token:} {id=21,slot_type=R_CURLY}
        |___Token:; {id=13,slot_type=eos}
------------------------------------------------------------


=================Reducing node 5, size=146==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@5
    package main;
    import (
     "fmt";
    );
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@2
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@3
    package main;
    import (
     "fmt";
    );
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@2
    package main;
    import (
     "fmt";
    );
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 5
------------------------------------------------------------


=================Reducing node 7, size=146==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=7}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 7
------------------------------------------------------------


================Reducing node 237, size=146=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 237
------------------------------------------------------------


================Reducing node 243, size=146=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A)
     ;
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 243
------------------------------------------------------------


================Reducing node 244, size=146=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=244}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 244
------------------------------------------------------------


================Reducing node 246, size=146=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 246
------------------------------------------------------------


================Reducing node 249, size=146=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=249}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]remove whole except first
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]dd@2
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     a.M[s] = s;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]dd@3
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.S = s;
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]dd@2
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_plus]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

2 entries are removed: 19 --> 17.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 19
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 249 from 146 to 140
------------------------------------------------------------


=================Reducing node 9, size=140==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 9
------------------------------------------------------------


=================Reducing node 54, size=140=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 54
------------------------------------------------------------


=================Reducing node 8, size=140==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 8
------------------------------------------------------------


================Reducing node 153, size=140=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 153
------------------------------------------------------------


=================Reducing node 6, size=140==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 6
------------------------------------------------------------


================Reducing node 433, size=140=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 433
------------------------------------------------------------


================Reducing node 435, size=140=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 435
------------------------------------------------------------


================Reducing node 438, size=140=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
     K
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
       int
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
     S
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
       string
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
     M
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
       map[string]string
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 438
------------------------------------------------------------


=================Reducing node 60, size=140=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{})
     ;
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 60
------------------------------------------------------------


=================Reducing node 61, size=140=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=61}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 61
------------------------------------------------------------


=================Reducing node 63, size=140=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 63
------------------------------------------------------------


=================Reducing node 66, size=140=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=66}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]remove whole except first
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(x);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=68}
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_plus]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

6 entries are removed: 30 --> 24.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 14
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 66 from 140 to 133
------------------------------------------------------------


=================Reducing node 10, size=133=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 10
------------------------------------------------------------


================Reducing node 441, size=133=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@3
    package main;
    import (
     "fmt";
    );
    type A struct {
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     S string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@2
    package main;
    import (
     "fmt";
    );
    type A struct {
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

2 entries are removed: 29 --> 27.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 5
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 441 from 133 to 130
------------------------------------------------------------


================Reducing node 252, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 252
------------------------------------------------------------


=================Reducing node 11, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 11
------------------------------------------------------------


================Reducing node 301, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M                          ;
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
           make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 301
------------------------------------------------------------


================Reducing node 159, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A)
     ;
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 159
------------------------------------------------------------


================Reducing node 160, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=160}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 160
------------------------------------------------------------


================Reducing node 242, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA                  (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string)       {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 242
------------------------------------------------------------


================Reducing node 162, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 162
------------------------------------------------------------


================Reducing node 165, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=165}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 165
------------------------------------------------------------


================Reducing node 166, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 166
------------------------------------------------------------


================Reducing node 253, size=130=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     a.M[s] = s;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

19 entries are removed: 35 --> 16.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 10
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 253 from 130 to 121
------------------------------------------------------------


================Reducing node 170, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
            1              ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
               newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 170
------------------------------------------------------------


================Reducing node 158, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy()              {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy   (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 158
------------------------------------------------------------


================Reducing node 129, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 129
------------------------------------------------------------


=================Reducing node 17, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main()
     ;
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 17
------------------------------------------------------------


=================Reducing node 18, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=18}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 18
------------------------------------------------------------


================Reducing node 307, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make                   ;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M =          string        ;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M =                 string ;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 307
------------------------------------------------------------


================Reducing node 172, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return                ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 172
------------------------------------------------------------


================Reducing node 173, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=173}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1              ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return    newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 173
------------------------------------------------------------


================Reducing node 445, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 445
------------------------------------------------------------


================Reducing node 394, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 394
------------------------------------------------------------


================Reducing node 309, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make                   ;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 309
------------------------------------------------------------


================Reducing node 311, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=311}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 311
------------------------------------------------------------


================Reducing node 211, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy()              {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 211
------------------------------------------------------------


================Reducing node 213, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=213}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy()    int       {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy()  x           {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 213
------------------------------------------------------------


================Reducing node 175, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1              ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 175
------------------------------------------------------------


================Reducing node 176, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=176}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 176
------------------------------------------------------------


================Reducing node 131, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(                    ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 131
------------------------------------------------------------


================Reducing node 133, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=133}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int               ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(       a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 133
------------------------------------------------------------


=================Reducing node 68, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 68
------------------------------------------------------------


=================Reducing node 20, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 20
------------------------------------------------------------


=================Reducing node 23, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=23}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 23
------------------------------------------------------------


=================Reducing node 24, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 24
------------------------------------------------------------


================Reducing node 446, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M                  ;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
           string       ;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
                  string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 446
------------------------------------------------------------


================Reducing node 250, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 250
------------------------------------------------------------


================Reducing node 180, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA        ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1,      2      ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 180
------------------------------------------------------------


=================Reducing node 76, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
                 a ;
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println   ;
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 76
------------------------------------------------------------


=================Reducing node 34, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume         ;
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
             proxy() ;
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 34
------------------------------------------------------------


=================Reducing node 4, size=121==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 4
------------------------------------------------------------


================Reducing node 479, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=479}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 479
------------------------------------------------------------


================Reducing node 480, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 480
------------------------------------------------------------


================Reducing node 451, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M     string       ;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M            string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 451
------------------------------------------------------------


================Reducing node 410, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(               ) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 410
------------------------------------------------------------


================Reducing node 412, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=412}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int          ) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(       s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 412
------------------------------------------------------------


================Reducing node 372, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
           k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K    ;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 372
------------------------------------------------------------


================Reducing node 313, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(                 );
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 313
------------------------------------------------------------


================Reducing node 317, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=317}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(    string       );
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(           string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 317
------------------------------------------------------------


================Reducing node 215, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (          ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 215
------------------------------------------------------------


================Reducing node 217, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=217}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int     ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (       a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 217
------------------------------------------------------------


================Reducing node 182, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA        ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 182
------------------------------------------------------------


================Reducing node 184, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=184}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 184
------------------------------------------------------------


================Reducing node 135, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int               ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 135
------------------------------------------------------------


================Reducing node 136, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=136}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 136
------------------------------------------------------------


================Reducing node 395, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string)       {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 395
------------------------------------------------------------


================Reducing node 397, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=397}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string)    A  {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string)  a    {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 397
------------------------------------------------------------


================Reducing node 138, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a            ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int,   interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 138
------------------------------------------------------------


================Reducing node 443, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 443
------------------------------------------------------------


================Reducing node 414, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int          ) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 414
------------------------------------------------------------


================Reducing node 415, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=415}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 415
------------------------------------------------------------


================Reducing node 387, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a   = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
       K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 387
------------------------------------------------------------


================Reducing node 335, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a   = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
       M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 335
------------------------------------------------------------


================Reducing node 219, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int     ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 219
------------------------------------------------------------


================Reducing node 220, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=220}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 220
------------------------------------------------------------


================Reducing node 186, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(      );
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 186
------------------------------------------------------------


================Reducing node 189, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=189}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2     );
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(   "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 189
------------------------------------------------------------


================Reducing node 141, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 141
------------------------------------------------------------


=================Reducing node 92, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt        (a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
         Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 92
------------------------------------------------------------


=================Reducing node 78, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println   ;
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 78
------------------------------------------------------------


=================Reducing node 80, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=80}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 80
------------------------------------------------------------


=================Reducing node 40, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy  );
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 40
------------------------------------------------------------


================Reducing node 485, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 485
------------------------------------------------------------


================Reducing node 487, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=487}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 487
------------------------------------------------------------


================Reducing node 471, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K    ;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
       int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 471
------------------------------------------------------------


================Reducing node 417, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int,   string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s       ) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 417
------------------------------------------------------------


================Reducing node 413, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(  int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k    , s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 413
------------------------------------------------------------


================Reducing node 399, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (   ) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 399
------------------------------------------------------------


================Reducing node 402, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=402}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (  A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a  ) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 402
------------------------------------------------------------


================Reducing node 254, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 254
------------------------------------------------------------


================Reducing node 222, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int,   A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a  ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 222
------------------------------------------------------------


================Reducing node 218, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (  int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x    , a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 218
------------------------------------------------------------


================Reducing node 210, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 210
------------------------------------------------------------


================Reducing node 191, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2     );
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 191
------------------------------------------------------------


================Reducing node 192, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=192}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 192
------------------------------------------------------------


================Reducing node 134, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(  int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x    , a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 134
------------------------------------------------------------


=================Reducing node 51, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 51
------------------------------------------------------------


=================Reducing node 42, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy  );
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 42
------------------------------------------------------------


=================Reducing node 44, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=44}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 44
------------------------------------------------------------


=================Reducing node 2, size=121==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2
------------------------------------------------------------


================Reducing node 496, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 496
------------------------------------------------------------


================Reducing node 495, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 495
------------------------------------------------------------


================Reducing node 494, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 494
------------------------------------------------------------


================Reducing node 493, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 493
------------------------------------------------------------


================Reducing node 490, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 490
------------------------------------------------------------


================Reducing node 486, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 486
------------------------------------------------------------


================Reducing node 484, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 484
------------------------------------------------------------


================Reducing node 483, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 483
------------------------------------------------------------


================Reducing node 482, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 482
------------------------------------------------------------


================Reducing node 478, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 478
------------------------------------------------------------


================Reducing node 477, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 477
------------------------------------------------------------


================Reducing node 473, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 473
------------------------------------------------------------


================Reducing node 462, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 462
------------------------------------------------------------


================Reducing node 461, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 461
------------------------------------------------------------


================Reducing node 459, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 459
------------------------------------------------------------


================Reducing node 455, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 455
------------------------------------------------------------


================Reducing node 453, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 453
------------------------------------------------------------


================Reducing node 452, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 452
------------------------------------------------------------


================Reducing node 448, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 448
------------------------------------------------------------


================Reducing node 442, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 442
------------------------------------------------------------


================Reducing node 440, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 440
------------------------------------------------------------


================Reducing node 439, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 439
------------------------------------------------------------


================Reducing node 436, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 436
------------------------------------------------------------


================Reducing node 434, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 434
------------------------------------------------------------


================Reducing node 432, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 432
------------------------------------------------------------


================Reducing node 427, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 427
------------------------------------------------------------


================Reducing node 424, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(  int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 424
------------------------------------------------------------


================Reducing node 429, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 429
------------------------------------------------------------


================Reducing node 421, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 421
------------------------------------------------------------


================Reducing node 418, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int,   string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 418
------------------------------------------------------------


================Reducing node 423, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 423
------------------------------------------------------------


================Reducing node 416, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 416
------------------------------------------------------------


================Reducing node 411, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 411
------------------------------------------------------------


================Reducing node 409, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 409
------------------------------------------------------------


================Reducing node 406, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 406
------------------------------------------------------------


================Reducing node 403, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (  A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 403
------------------------------------------------------------


================Reducing node 408, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 408
------------------------------------------------------------


================Reducing node 400, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 400
------------------------------------------------------------


================Reducing node 398, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 398
------------------------------------------------------------


================Reducing node 393, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 393
------------------------------------------------------------


================Reducing node 390, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 390
------------------------------------------------------------


================Reducing node 389, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 389
------------------------------------------------------------


================Reducing node 382, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 382
------------------------------------------------------------


================Reducing node 381, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 381
------------------------------------------------------------


================Reducing node 370, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 370
------------------------------------------------------------


================Reducing node 341, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 341
------------------------------------------------------------


================Reducing node 338, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 338
------------------------------------------------------------


================Reducing node 337, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 337
------------------------------------------------------------


================Reducing node 330, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 330
------------------------------------------------------------


================Reducing node 329, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 329
------------------------------------------------------------


================Reducing node 327, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 327
------------------------------------------------------------


================Reducing node 325, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 325
------------------------------------------------------------


================Reducing node 321, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 321
------------------------------------------------------------


================Reducing node 319, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 319
------------------------------------------------------------


================Reducing node 318, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 318
------------------------------------------------------------


================Reducing node 314, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 314
------------------------------------------------------------


================Reducing node 312, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 312
------------------------------------------------------------


================Reducing node 299, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 299
------------------------------------------------------------


================Reducing node 259, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 259
------------------------------------------------------------


================Reducing node 257, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 257
------------------------------------------------------------


================Reducing node 247, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 247
------------------------------------------------------------


================Reducing node 245, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 245
------------------------------------------------------------


================Reducing node 241, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 241
------------------------------------------------------------


================Reducing node 240, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 240
------------------------------------------------------------


================Reducing node 239, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 239
------------------------------------------------------------


================Reducing node 236, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 236
------------------------------------------------------------


================Reducing node 235, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 235
------------------------------------------------------------


================Reducing node 232, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 232
------------------------------------------------------------


================Reducing node 229, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (  int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 229
------------------------------------------------------------


================Reducing node 234, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 234
------------------------------------------------------------


================Reducing node 226, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 226
------------------------------------------------------------


================Reducing node 223, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int,   A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 223
------------------------------------------------------------


================Reducing node 228, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 228
------------------------------------------------------------


================Reducing node 221, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 221
------------------------------------------------------------


================Reducing node 216, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 216
------------------------------------------------------------


================Reducing node 214, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 214
------------------------------------------------------------


================Reducing node 209, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 209
------------------------------------------------------------


================Reducing node 205, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 205
------------------------------------------------------------


================Reducing node 203, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 203
------------------------------------------------------------


================Reducing node 199, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 199
------------------------------------------------------------


================Reducing node 193, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 193
------------------------------------------------------------


================Reducing node 187, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 187
------------------------------------------------------------


================Reducing node 185, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 185
------------------------------------------------------------


================Reducing node 177, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 177
------------------------------------------------------------


================Reducing node 171, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 171
------------------------------------------------------------


================Reducing node 169, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 169
------------------------------------------------------------


================Reducing node 163, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 163
------------------------------------------------------------


================Reducing node 161, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 161
------------------------------------------------------------


================Reducing node 157, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 157
------------------------------------------------------------


================Reducing node 156, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 156
------------------------------------------------------------


================Reducing node 155, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 155
------------------------------------------------------------


================Reducing node 150, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 150
------------------------------------------------------------


================Reducing node 147, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(  int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 147
------------------------------------------------------------


================Reducing node 152, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 152
------------------------------------------------------------


================Reducing node 144, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 144
------------------------------------------------------------


================Reducing node 143, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 143
------------------------------------------------------------


================Reducing node 142, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 142
------------------------------------------------------------


================Reducing node 139, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int,   interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 139
------------------------------------------------------------


================Reducing node 146, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 146
------------------------------------------------------------


================Reducing node 137, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 137
------------------------------------------------------------


================Reducing node 132, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 132
------------------------------------------------------------


================Reducing node 130, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 130
------------------------------------------------------------


=================Reducing node 98, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 98
------------------------------------------------------------


=================Reducing node 95, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 95
------------------------------------------------------------


=================Reducing node 94, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 94
------------------------------------------------------------


=================Reducing node 83, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 83
------------------------------------------------------------


=================Reducing node 82, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println( );
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 82
------------------------------------------------------------


=================Reducing node 91, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 91
------------------------------------------------------------


=================Reducing node 81, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 81
------------------------------------------------------------


=================Reducing node 71, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 71
------------------------------------------------------------


=================Reducing node 64, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 64
------------------------------------------------------------


=================Reducing node 62, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 62
------------------------------------------------------------


=================Reducing node 58, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 58
------------------------------------------------------------


=================Reducing node 57, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 57
------------------------------------------------------------


=================Reducing node 56, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 56
------------------------------------------------------------


=================Reducing node 53, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 53
------------------------------------------------------------


=================Reducing node 52, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 52
------------------------------------------------------------


=================Reducing node 50, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 50
------------------------------------------------------------


=================Reducing node 48, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 48
------------------------------------------------------------


=================Reducing node 46, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 46
------------------------------------------------------------


=================Reducing node 45, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 45
------------------------------------------------------------


=================Reducing node 38, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 38
------------------------------------------------------------


=================Reducing node 36, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 36
------------------------------------------------------------


=================Reducing node 27, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 27
------------------------------------------------------------


=================Reducing node 21, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 21
------------------------------------------------------------


=================Reducing node 19, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 19
------------------------------------------------------------


=================Reducing node 15, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 15
------------------------------------------------------------


=================Reducing node 14, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 14
------------------------------------------------------------


=================Reducing node 13, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 13
------------------------------------------------------------


=================Reducing node 5, size=121==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@2
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@3
    package main;
    import (
     "fmt";
    );
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@2
    package main;
    import (
     "fmt";
    );
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 5
------------------------------------------------------------


=================Reducing node 7, size=121==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=7}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 7
------------------------------------------------------------


================Reducing node 206, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 206
------------------------------------------------------------


=================Reducing node 8, size=121==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=8}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 8
------------------------------------------------------------


================Reducing node 212, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A)
     ;
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 212
------------------------------------------------------------


================Reducing node 213, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=213}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 213
------------------------------------------------------------


================Reducing node 122, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 122
------------------------------------------------------------


================Reducing node 215, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 215
------------------------------------------------------------


================Reducing node 218, size=121=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=218}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]remove whole except first
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     a.M = make(map[string]string);
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_plus]dd@2
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_plus]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

85 entries are removed: 102 --> 17.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 110
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 218 from 121 to 108
------------------------------------------------------------


=================Reducing node 9, size=108==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 9
------------------------------------------------------------


=================Reducing node 54, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 54
------------------------------------------------------------


=================Reducing node 6, size=108==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 6
------------------------------------------------------------


================Reducing node 337, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 337
------------------------------------------------------------


================Reducing node 339, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 339
------------------------------------------------------------


=================Reducing node 10, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 10
------------------------------------------------------------


================Reducing node 342, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
     K
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
       int
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
     M
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A
       map[string]string
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 342
------------------------------------------------------------


=================Reducing node 11, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 11
------------------------------------------------------------


================Reducing node 128, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A)
     ;
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 128
------------------------------------------------------------


================Reducing node 129, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=129}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 129
------------------------------------------------------------


================Reducing node 211, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA                  (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string)       {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 211
------------------------------------------------------------


================Reducing node 345, size=108=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
     M map[string]string;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@2
    package main;
    import (
     "fmt";
    );
    type A struct {
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: pass=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===========TestScriptExecutionCacheEntryEviction============

8 entries are removed: 29 --> 21.
------------------------------------------------------------


===========Node edit action set cache is cleared.===========

    size before clearance = 13
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Succeeded to reduce node 345 from 108 to 101
------------------------------------------------------------


================Reducing node 131, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 131
------------------------------------------------------------


================Reducing node 134, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=134}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 134
------------------------------------------------------------


================Reducing node 135, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 135
------------------------------------------------------------


================Reducing node 139, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
            1              ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
               newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 139
------------------------------------------------------------


================Reducing node 127, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy()              {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy   (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 127
------------------------------------------------------------


=================Reducing node 98, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 98
------------------------------------------------------------


=================Reducing node 60, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{})
     ;
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 60
------------------------------------------------------------


=================Reducing node 61, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=61}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 61
------------------------------------------------------------


=================Reducing node 17, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main()
     ;
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 17
------------------------------------------------------------


=================Reducing node 18, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=18}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 18
------------------------------------------------------------


================Reducing node 141, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return                ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 141
------------------------------------------------------------


================Reducing node 142, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=142}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1              ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return    newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 142
------------------------------------------------------------


================Reducing node 298, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 298
------------------------------------------------------------


================Reducing node 180, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy()              {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 180
------------------------------------------------------------


================Reducing node 182, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=182}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy()    int       {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy()  x           {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 182
------------------------------------------------------------


================Reducing node 144, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1              ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 144
------------------------------------------------------------


================Reducing node 145, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=145}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 145
------------------------------------------------------------


================Reducing node 100, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(                    ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 100
------------------------------------------------------------


================Reducing node 102, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=102}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int               ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(       a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 102
------------------------------------------------------------


=================Reducing node 63, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 63
------------------------------------------------------------


=================Reducing node 66, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=66}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 66
------------------------------------------------------------


=================Reducing node 67, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 67
------------------------------------------------------------


=================Reducing node 20, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 20
------------------------------------------------------------


=================Reducing node 23, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=23}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 23
------------------------------------------------------------


=================Reducing node 24, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 24
------------------------------------------------------------


================Reducing node 219, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 219
------------------------------------------------------------


================Reducing node 149, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA        ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1,      2      ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 149
------------------------------------------------------------


=================Reducing node 75, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
                 a ;
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println   ;
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 75
------------------------------------------------------------


=================Reducing node 34, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume         ;
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
             proxy() ;
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 34
------------------------------------------------------------


=================Reducing node 4, size=101==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 4
------------------------------------------------------------


================Reducing node 374, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=374}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 374
------------------------------------------------------------


================Reducing node 375, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 375
------------------------------------------------------------


================Reducing node 314, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(               ) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 314
------------------------------------------------------------


================Reducing node 316, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=316}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int          ) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(       s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 316
------------------------------------------------------------


================Reducing node 276, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
           k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K    ;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 276
------------------------------------------------------------


================Reducing node 184, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (          ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 184
------------------------------------------------------------


================Reducing node 186, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=186}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int     ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (       a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 186
------------------------------------------------------------


================Reducing node 151, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA        ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 151
------------------------------------------------------------


================Reducing node 153, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=153}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 153
------------------------------------------------------------


================Reducing node 104, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int               ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 104
------------------------------------------------------------


================Reducing node 105, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=105}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 105
------------------------------------------------------------


================Reducing node 299, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string)       {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 299
------------------------------------------------------------


================Reducing node 301, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=301}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string)    A  {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string)  a    {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 301
------------------------------------------------------------


================Reducing node 107, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a            ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int,   interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 107
------------------------------------------------------------


================Reducing node 347, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=347}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 347
------------------------------------------------------------


================Reducing node 318, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int          ) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 318
------------------------------------------------------------


================Reducing node 319, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=319}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 319
------------------------------------------------------------


================Reducing node 291, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a   = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
       K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 291
------------------------------------------------------------


================Reducing node 188, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int     ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 188
------------------------------------------------------------


================Reducing node 189, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=189}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 189
------------------------------------------------------------


================Reducing node 155, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(      );
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 155
------------------------------------------------------------


================Reducing node 158, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=158}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2     );
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(   "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 158
------------------------------------------------------------


================Reducing node 110, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 110
------------------------------------------------------------


=================Reducing node 91, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt        (a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
         Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 91
------------------------------------------------------------


=================Reducing node 77, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println   ;
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 77
------------------------------------------------------------


=================Reducing node 79, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=79}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 79
------------------------------------------------------------


=================Reducing node 40, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy  );
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 40
------------------------------------------------------------


================Reducing node 380, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 380
------------------------------------------------------------


================Reducing node 382, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=382}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 382
------------------------------------------------------------


================Reducing node 366, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K    ;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
       int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 366
------------------------------------------------------------


================Reducing node 321, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int,   string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s       ) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 321
------------------------------------------------------------


================Reducing node 317, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(  int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k    , s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 317
------------------------------------------------------------


================Reducing node 303, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (   ) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 303
------------------------------------------------------------


================Reducing node 306, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=306}
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (  A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a  ) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 306
------------------------------------------------------------


================Reducing node 221, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular_node]can be epsilon
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 221
------------------------------------------------------------


================Reducing node 191, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int,   A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a  ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 191
------------------------------------------------------------


================Reducing node 187, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (  int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x    , a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 187
------------------------------------------------------------


================Reducing node 179, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 179
------------------------------------------------------------


================Reducing node 160, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2     );
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 160
------------------------------------------------------------


================Reducing node 161, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=161}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 161
------------------------------------------------------------


================Reducing node 103, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(  int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x    , a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 103
------------------------------------------------------------


=================Reducing node 51, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 51
------------------------------------------------------------


=================Reducing node 42, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy  );
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 42
------------------------------------------------------------


=================Reducing node 44, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=44}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 44
------------------------------------------------------------


=================Reducing node 2, size=101==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2
------------------------------------------------------------


================Reducing node 391, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 391
------------------------------------------------------------


================Reducing node 390, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 390
------------------------------------------------------------


================Reducing node 389, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 389
------------------------------------------------------------


================Reducing node 388, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 388
------------------------------------------------------------


================Reducing node 385, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 385
------------------------------------------------------------


================Reducing node 381, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 381
------------------------------------------------------------


================Reducing node 379, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 379
------------------------------------------------------------


================Reducing node 378, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 378
------------------------------------------------------------


================Reducing node 377, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 377
------------------------------------------------------------


================Reducing node 373, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 373
------------------------------------------------------------


================Reducing node 372, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 372
------------------------------------------------------------


================Reducing node 368, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 368
------------------------------------------------------------


================Reducing node 346, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 346
------------------------------------------------------------


================Reducing node 344, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 344
------------------------------------------------------------


================Reducing node 343, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 343
------------------------------------------------------------


================Reducing node 340, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 340
------------------------------------------------------------


================Reducing node 338, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 338
------------------------------------------------------------


================Reducing node 336, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 336
------------------------------------------------------------


================Reducing node 331, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 331
------------------------------------------------------------


================Reducing node 328, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(  int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 328
------------------------------------------------------------


================Reducing node 333, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 333
------------------------------------------------------------


================Reducing node 325, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 325
------------------------------------------------------------


================Reducing node 322, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int,   string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 322
------------------------------------------------------------


================Reducing node 327, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 327
------------------------------------------------------------


================Reducing node 320, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 320
------------------------------------------------------------


================Reducing node 315, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 315
------------------------------------------------------------


================Reducing node 313, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 313
------------------------------------------------------------


================Reducing node 310, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 310
------------------------------------------------------------


================Reducing node 307, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (  A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 307
------------------------------------------------------------


================Reducing node 312, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 312
------------------------------------------------------------


================Reducing node 304, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 304
------------------------------------------------------------


================Reducing node 302, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 302
------------------------------------------------------------


================Reducing node 297, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 297
------------------------------------------------------------


================Reducing node 294, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 294
------------------------------------------------------------


================Reducing node 293, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 293
------------------------------------------------------------


================Reducing node 286, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 286
------------------------------------------------------------


================Reducing node 285, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 285
------------------------------------------------------------


================Reducing node 274, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 274
------------------------------------------------------------


================Reducing node 226, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 226
------------------------------------------------------------


================Reducing node 224, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 224
------------------------------------------------------------


================Reducing node 216, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 216
------------------------------------------------------------


================Reducing node 214, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 214
------------------------------------------------------------


================Reducing node 210, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 210
------------------------------------------------------------


================Reducing node 209, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 209
------------------------------------------------------------


================Reducing node 208, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 208
------------------------------------------------------------


================Reducing node 205, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 205
------------------------------------------------------------


================Reducing node 204, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 204
------------------------------------------------------------


================Reducing node 201, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 201
------------------------------------------------------------


================Reducing node 198, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (  int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 198
------------------------------------------------------------


================Reducing node 203, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 203
------------------------------------------------------------


================Reducing node 195, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 195
------------------------------------------------------------


================Reducing node 192, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int,   A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 192
------------------------------------------------------------


================Reducing node 197, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 197
------------------------------------------------------------


================Reducing node 190, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 190
------------------------------------------------------------


================Reducing node 185, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 185
------------------------------------------------------------


================Reducing node 183, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 183
------------------------------------------------------------


================Reducing node 178, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 178
------------------------------------------------------------


================Reducing node 174, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 174
------------------------------------------------------------


================Reducing node 172, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 172
------------------------------------------------------------


================Reducing node 168, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 168
------------------------------------------------------------


================Reducing node 162, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 162
------------------------------------------------------------


================Reducing node 156, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 156
------------------------------------------------------------


================Reducing node 154, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 154
------------------------------------------------------------


================Reducing node 146, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 146
------------------------------------------------------------


================Reducing node 140, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 140
------------------------------------------------------------


================Reducing node 138, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 138
------------------------------------------------------------


================Reducing node 132, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 132
------------------------------------------------------------


================Reducing node 130, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 130
------------------------------------------------------------


================Reducing node 126, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 126
------------------------------------------------------------


================Reducing node 125, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 125
------------------------------------------------------------


================Reducing node 124, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 124
------------------------------------------------------------


================Reducing node 119, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 119
------------------------------------------------------------


================Reducing node 116, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(  int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 116
------------------------------------------------------------


================Reducing node 121, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 121
------------------------------------------------------------


================Reducing node 113, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 113
------------------------------------------------------------


================Reducing node 112, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 112
------------------------------------------------------------


================Reducing node 111, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 111
------------------------------------------------------------


================Reducing node 108, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int,   interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 108
------------------------------------------------------------


================Reducing node 115, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 115
------------------------------------------------------------


================Reducing node 106, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 106
------------------------------------------------------------


================Reducing node 101, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 101
------------------------------------------------------------


=================Reducing node 99, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 99
------------------------------------------------------------


=================Reducing node 97, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 97
------------------------------------------------------------


=================Reducing node 94, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 94
------------------------------------------------------------


=================Reducing node 93, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 93
------------------------------------------------------------


=================Reducing node 82, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 82
------------------------------------------------------------


=================Reducing node 81, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println( );
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 81
------------------------------------------------------------


=================Reducing node 90, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 90
------------------------------------------------------------


=================Reducing node 80, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 80
------------------------------------------------------------


=================Reducing node 70, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 70
------------------------------------------------------------


=================Reducing node 64, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 64
------------------------------------------------------------


=================Reducing node 62, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 62
------------------------------------------------------------


=================Reducing node 58, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 58
------------------------------------------------------------


=================Reducing node 57, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 57
------------------------------------------------------------


=================Reducing node 56, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 56
------------------------------------------------------------


=================Reducing node 53, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 53
------------------------------------------------------------


=================Reducing node 52, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 52
------------------------------------------------------------


=================Reducing node 50, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 50
------------------------------------------------------------


=================Reducing node 48, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 48
------------------------------------------------------------


=================Reducing node 46, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 46
------------------------------------------------------------


=================Reducing node 45, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 45
------------------------------------------------------------


=================Reducing node 38, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 38
------------------------------------------------------------


=================Reducing node 36, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 36
------------------------------------------------------------


=================Reducing node 27, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 27
------------------------------------------------------------


=================Reducing node 21, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 21
------------------------------------------------------------


=================Reducing node 19, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 19
------------------------------------------------------------


=================Reducing node 15, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 15
------------------------------------------------------------


=================Reducing node 14, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 14
------------------------------------------------------------


=================Reducing node 13, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 13
------------------------------------------------------------


=================Reducing node 5, size=101==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@2
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 5
------------------------------------------------------------


=================Reducing node 8, size=101==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=8}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 8
------------------------------------------------------------


=================Reducing node 7, size=101==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=7}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 7
------------------------------------------------------------


================Reducing node 206, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 206
------------------------------------------------------------


================Reducing node 122, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 122
------------------------------------------------------------


=================Reducing node 9, size=101==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=9}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 9
------------------------------------------------------------


=================Reducing node 54, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 54
------------------------------------------------------------


=================Reducing node 10, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=10}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 10
------------------------------------------------------------


=================Reducing node 11, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 11
------------------------------------------------------------


================Reducing node 128, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A)
     ;
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 128
------------------------------------------------------------


================Reducing node 129, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=129}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 129
------------------------------------------------------------


================Reducing node 211, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string)       {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [regular node]compatible replacement
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA                  (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 211
------------------------------------------------------------


================Reducing node 212, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A)
     ;
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 212
------------------------------------------------------------


================Reducing node 213, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=213}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 213
------------------------------------------------------------


================Reducing node 131, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 131
------------------------------------------------------------


================Reducing node 134, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=134}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 134
------------------------------------------------------------


================Reducing node 135, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 135
------------------------------------------------------------


================Reducing node 139, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
            1              ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
               newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 139
------------------------------------------------------------


================Reducing node 127, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy()              {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy   (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 127
------------------------------------------------------------


=================Reducing node 98, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 98
------------------------------------------------------------


=================Reducing node 60, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{})
     ;
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 60
------------------------------------------------------------


=================Reducing node 61, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=61}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 61
------------------------------------------------------------


=================Reducing node 17, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main()
     ;
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 17
------------------------------------------------------------


=================Reducing node 18, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=18}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 18
------------------------------------------------------------


=================Reducing node 6, size=101==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=6}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 6
------------------------------------------------------------


================Reducing node 291, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 291
------------------------------------------------------------


================Reducing node 215, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


============Testing the following program: fail=============

// edit action set type: [kleene_star]dd@1
    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 215
------------------------------------------------------------


================Reducing node 218, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=218}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=220}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 218
------------------------------------------------------------


================Reducing node 141, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return                ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 141
------------------------------------------------------------


================Reducing node 142, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=142}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1              ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return    newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 142
------------------------------------------------------------


================Reducing node 293, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 293
------------------------------------------------------------


================Reducing node 252, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 252
------------------------------------------------------------


================Reducing node 180, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy()              {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 180
------------------------------------------------------------


================Reducing node 182, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=182}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy()    int       {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy()  x           {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 182
------------------------------------------------------------


================Reducing node 144, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1              ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 144
------------------------------------------------------------


================Reducing node 145, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=145}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 145
------------------------------------------------------------


================Reducing node 100, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(                    ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 100
------------------------------------------------------------


================Reducing node 102, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=102}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int               ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(       a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 102
------------------------------------------------------------


=================Reducing node 63, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 63
------------------------------------------------------------


=================Reducing node 66, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=66}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 66
------------------------------------------------------------


=================Reducing node 67, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 67
------------------------------------------------------------


=================Reducing node 20, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 20
------------------------------------------------------------


=================Reducing node 23, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=23}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 23
------------------------------------------------------------


=================Reducing node 24, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 24
------------------------------------------------------------


================Reducing node 296, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A
     K
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A
       int
     ;
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 296
------------------------------------------------------------


================Reducing node 219, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=219}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 219
------------------------------------------------------------


================Reducing node 149, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA        ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1,      2      ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 149
------------------------------------------------------------


=================Reducing node 75, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
                 a ;
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println   ;
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 75
------------------------------------------------------------


=================Reducing node 34, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume         ;
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
             proxy() ;
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 34
------------------------------------------------------------


=================Reducing node 4, size=101==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 4
------------------------------------------------------------


================Reducing node 310, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=310}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 310
------------------------------------------------------------


================Reducing node 311, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 311
------------------------------------------------------------


================Reducing node 268, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(               ) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 268
------------------------------------------------------------


================Reducing node 270, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=270}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int          ) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(       s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 270
------------------------------------------------------------


================Reducing node 230, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
           k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K    ;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 230
------------------------------------------------------------


================Reducing node 184, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (          ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 184
------------------------------------------------------------


================Reducing node 186, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=186}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int     ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (       a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 186
------------------------------------------------------------


================Reducing node 151, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA        ;
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 151
------------------------------------------------------------


================Reducing node 153, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=153}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 153
------------------------------------------------------------


================Reducing node 104, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int               ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 104
------------------------------------------------------------


================Reducing node 105, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=105}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 105
------------------------------------------------------------


================Reducing node 253, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string)       {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 253
------------------------------------------------------------


================Reducing node 255, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=255}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string)    A  {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string)  a    {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 255
------------------------------------------------------------


================Reducing node 107, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a            ) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int,   interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 107
------------------------------------------------------------


================Reducing node 299, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 299
------------------------------------------------------------


================Reducing node 301, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=301}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 301
------------------------------------------------------------


================Reducing node 272, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int          ) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 272
------------------------------------------------------------


================Reducing node 273, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=273}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 273
------------------------------------------------------------


================Reducing node 245, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a   = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
       K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 245
------------------------------------------------------------


================Reducing node 188, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int     ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 188
------------------------------------------------------------


================Reducing node 189, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=189}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 189
------------------------------------------------------------


================Reducing node 155, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(      );
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 155
------------------------------------------------------------


================Reducing node 158, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=158}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2     );
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(   "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 158
------------------------------------------------------------


================Reducing node 110, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 110
------------------------------------------------------------


=================Reducing node 91, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt        (a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
         Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 91
------------------------------------------------------------


=================Reducing node 77, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println   ;
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 77
------------------------------------------------------------


=================Reducing node 79, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=79}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 79
------------------------------------------------------------


=================Reducing node 40, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy  );
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 40
------------------------------------------------------------


================Reducing node 316, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 316
------------------------------------------------------------


================Reducing node 318, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=318}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 318
------------------------------------------------------------


================Reducing node 302, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K    ;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
       int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 302
------------------------------------------------------------


================Reducing node 275, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int,   string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s       ) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 275
------------------------------------------------------------


================Reducing node 271, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(  int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k    , s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 271
------------------------------------------------------------


================Reducing node 257, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (   ) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 257
------------------------------------------------------------


================Reducing node 260, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=260}
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (  A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a  ) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 260
------------------------------------------------------------


================Reducing node 220, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=220}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 220
------------------------------------------------------------


================Reducing node 191, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int,   A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a  ) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 191
------------------------------------------------------------


================Reducing node 187, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (  int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x    , a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 187
------------------------------------------------------------


================Reducing node 179, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 179
------------------------------------------------------------


================Reducing node 160, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2     );
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 160
------------------------------------------------------------


================Reducing node 161, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=161}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 161
------------------------------------------------------------


================Reducing node 103, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(  int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x    , a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 103
------------------------------------------------------------


=================Reducing node 51, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 51
------------------------------------------------------------


=================Reducing node 42, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy  );
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 42
------------------------------------------------------------


=================Reducing node 44, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


==============Node edit action set cache hit.===============

    NodeDeletionAction{target_node=44}
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 44
------------------------------------------------------------


=================Reducing node 2, size=101==================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 2
------------------------------------------------------------


================Reducing node 327, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 327
------------------------------------------------------------


================Reducing node 326, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 326
------------------------------------------------------------


================Reducing node 325, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 325
------------------------------------------------------------


================Reducing node 324, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 324
------------------------------------------------------------


================Reducing node 321, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 321
------------------------------------------------------------


================Reducing node 317, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 317
------------------------------------------------------------


================Reducing node 315, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 315
------------------------------------------------------------


================Reducing node 314, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 314
------------------------------------------------------------


================Reducing node 313, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 313
------------------------------------------------------------


================Reducing node 309, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 309
------------------------------------------------------------


================Reducing node 308, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 308
------------------------------------------------------------


================Reducing node 304, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 304
------------------------------------------------------------


================Reducing node 300, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 300
------------------------------------------------------------


================Reducing node 298, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 298
------------------------------------------------------------


================Reducing node 297, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 297
------------------------------------------------------------


================Reducing node 294, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 294
------------------------------------------------------------


================Reducing node 292, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 292
------------------------------------------------------------


================Reducing node 290, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 290
------------------------------------------------------------


================Reducing node 285, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 285
------------------------------------------------------------


================Reducing node 282, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(  int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 282
------------------------------------------------------------


================Reducing node 287, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 287
------------------------------------------------------------


================Reducing node 279, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 279
------------------------------------------------------------


================Reducing node 276, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int,   string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 276
------------------------------------------------------------


================Reducing node 281, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 281
------------------------------------------------------------


================Reducing node 274, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 274
------------------------------------------------------------


================Reducing node 269, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 269
------------------------------------------------------------


================Reducing node 267, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 267
------------------------------------------------------------


================Reducing node 264, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 264
------------------------------------------------------------


================Reducing node 261, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (  A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 261
------------------------------------------------------------


================Reducing node 266, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 266
------------------------------------------------------------


================Reducing node 258, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 258
------------------------------------------------------------


================Reducing node 256, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 256
------------------------------------------------------------


================Reducing node 251, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 251
------------------------------------------------------------


================Reducing node 248, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 248
------------------------------------------------------------


================Reducing node 247, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 247
------------------------------------------------------------


================Reducing node 240, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 240
------------------------------------------------------------


================Reducing node 239, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 239
------------------------------------------------------------


================Reducing node 228, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 228
------------------------------------------------------------


================Reducing node 225, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 225
------------------------------------------------------------


================Reducing node 223, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 223
------------------------------------------------------------


================Reducing node 216, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 216
------------------------------------------------------------


================Reducing node 214, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 214
------------------------------------------------------------


================Reducing node 210, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 210
------------------------------------------------------------


================Reducing node 209, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 209
------------------------------------------------------------


================Reducing node 208, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 208
------------------------------------------------------------


================Reducing node 205, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 205
------------------------------------------------------------


================Reducing node 204, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 204
------------------------------------------------------------


================Reducing node 201, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 201
------------------------------------------------------------


================Reducing node 198, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (  int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 198
------------------------------------------------------------


================Reducing node 203, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 203
------------------------------------------------------------


================Reducing node 195, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 195
------------------------------------------------------------


================Reducing node 192, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int,   A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 192
------------------------------------------------------------


================Reducing node 197, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 197
------------------------------------------------------------


================Reducing node 190, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 190
------------------------------------------------------------


================Reducing node 185, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 185
------------------------------------------------------------


================Reducing node 183, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 183
------------------------------------------------------------


================Reducing node 178, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 178
------------------------------------------------------------


================Reducing node 174, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 174
------------------------------------------------------------


================Reducing node 172, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 172
------------------------------------------------------------


================Reducing node 168, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 168
------------------------------------------------------------


================Reducing node 162, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 162
------------------------------------------------------------


================Reducing node 156, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 156
------------------------------------------------------------


================Reducing node 154, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 154
------------------------------------------------------------


================Reducing node 146, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 146
------------------------------------------------------------


================Reducing node 140, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 140
------------------------------------------------------------


================Reducing node 138, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 138
------------------------------------------------------------


================Reducing node 132, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 132
------------------------------------------------------------


================Reducing node 130, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 130
------------------------------------------------------------


================Reducing node 126, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 126
------------------------------------------------------------


================Reducing node 125, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 125
------------------------------------------------------------


================Reducing node 124, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 124
------------------------------------------------------------


================Reducing node 119, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 119
------------------------------------------------------------


================Reducing node 116, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(  int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 116
------------------------------------------------------------


================Reducing node 121, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 121
------------------------------------------------------------


================Reducing node 113, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 113
------------------------------------------------------------


================Reducing node 112, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 112
------------------------------------------------------------


================Reducing node 111, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 111
------------------------------------------------------------


================Reducing node 108, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int,   interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 108
------------------------------------------------------------


================Reducing node 115, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 115
------------------------------------------------------------


================Reducing node 106, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 106
------------------------------------------------------------


================Reducing node 101, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 101
------------------------------------------------------------


=================Reducing node 99, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 99
------------------------------------------------------------


=================Reducing node 97, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 97
------------------------------------------------------------


=================Reducing node 94, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 94
------------------------------------------------------------


=================Reducing node 93, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 93
------------------------------------------------------------


=================Reducing node 82, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 82
------------------------------------------------------------


=================Reducing node 81, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


=========Cache hit for the following program: fail==========

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println( );
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 81
------------------------------------------------------------


=================Reducing node 90, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 90
------------------------------------------------------------


=================Reducing node 80, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 80
------------------------------------------------------------


=================Reducing node 70, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 70
------------------------------------------------------------


=================Reducing node 64, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 64
------------------------------------------------------------


=================Reducing node 62, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 62
------------------------------------------------------------


=================Reducing node 58, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 58
------------------------------------------------------------


=================Reducing node 57, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 57
------------------------------------------------------------


=================Reducing node 56, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 56
------------------------------------------------------------


=================Reducing node 53, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 53
------------------------------------------------------------


=================Reducing node 52, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 52
------------------------------------------------------------


=================Reducing node 50, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 50
------------------------------------------------------------


=================Reducing node 48, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 48
------------------------------------------------------------


=================Reducing node 46, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 46
------------------------------------------------------------


=================Reducing node 45, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 45
------------------------------------------------------------


=================Reducing node 38, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 38
------------------------------------------------------------


=================Reducing node 36, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 36
------------------------------------------------------------


=================Reducing node 27, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 27
------------------------------------------------------------


=================Reducing node 21, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 21
------------------------------------------------------------


=================Reducing node 19, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 19
------------------------------------------------------------


=================Reducing node 15, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 15
------------------------------------------------------------


=================Reducing node 14, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 14
------------------------------------------------------------


=================Reducing node 13, size=101=================

The current best program is the following

    package main;
    import (
     "fmt";
    );
    type A struct {
     K int;
    };
    func newA(k int, s string) (a A) {
     a.K = k;
     return;
    };
    func proxy() (x int, a A) {
     return 1, newA(2, "3");
    };
    func consume(x int, a interface{}) {
     fmt.Println(a);
    };
    func main() {
     consume(proxy());
    };
------------------------------------------------------------


===================Node reduction is done===================

Failed to reduce node 13
------------------------------------------------------------


#test success = 6
#test failure = 214
#test result cache hits = 135
#test execution cancelled = 0
#node edit action set cache hits = 94
