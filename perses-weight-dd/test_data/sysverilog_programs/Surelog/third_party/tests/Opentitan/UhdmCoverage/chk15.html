
<!DOCTYPE html>
<html>
<head>
<style>
body {

}
p {
font-size: 14px;
}</style>
<h3>hw/vendor/lowrisc_ibex/rtl/ibex_load_store_unit.sv Cov: 100% </h3>
<pre style="margin:0; padding:0 ">   1: // Copyright lowRISC contributors.</pre>
<pre style="margin:0; padding:0 ">   2: // Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.</pre>
<pre style="margin:0; padding:0 ">   3: // Licensed under the Apache License, Version 2.0, see LICENSE for details.</pre>
<pre style="margin:0; padding:0 ">   4: // SPDX-License-Identifier: Apache-2.0</pre>
<pre style="margin:0; padding:0 ">   5: </pre>
<pre style="margin:0; padding:0 ">   6: /**</pre>
<pre style="margin:0; padding:0 ">   7:  * Load Store Unit</pre>
<pre style="margin:0; padding:0 ">   8:  *</pre>
<pre style="margin:0; padding:0 ">   9:  * Load Store Unit, used to eliminate multiple access during processor stalls,</pre>
<pre style="margin:0; padding:0 ">  10:  * and to align bytes and halfwords.</pre>
<pre style="margin:0; padding:0 ">  11:  */</pre>
<pre style="margin:0; padding:0 ">  12: module ibex_load_store_unit (</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  13:     input  logic         clk_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  14:     input  logic         rst_ni,</pre>
<pre style="margin:0; padding:0 ">  15: </pre>
<pre style="margin:0; padding:0 ">  16:     // data interface</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  17:     output logic         data_req_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  18:     input  logic         data_gnt_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  19:     input  logic         data_rvalid_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  20:     input  logic         data_err_i,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  21:     input  logic         data_pmp_err_i,</pre>
<pre style="margin:0; padding:0 ">  22: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  23:     output logic [31:0]  data_addr_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  24:     output logic         data_we_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  25:     output logic [3:0]   data_be_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  26:     output logic [31:0]  data_wdata_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  27:     input  logic [31:0]  data_rdata_i,</pre>
<pre style="margin:0; padding:0 ">  28: </pre>
<pre style="margin:0; padding:0 ">  29:     // signals to/from ID/EX stage</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  30:     input  logic         data_we_ex_i,         // write enable                     -> from ID/EX</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  31:     input  logic [1:0]   data_type_ex_i,       // data type: word, half word, byte -> from ID/EX</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  32:     input  logic [31:0]  data_wdata_ex_i,      // data to write to memory          -> from ID/EX</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  33:     input  logic         data_sign_ext_ex_i,   // sign extension                   -> from ID/EX</pre>
<pre style="margin:0; padding:0 ">  34: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  35:     output logic [31:0]  data_rdata_ex_o,      // requested data                   -> to ID/EX</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  36:     input  logic         data_req_ex_i,        // data request                     -> from ID/EX</pre>
<pre style="margin:0; padding:0 ">  37: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  38:     input  logic [31:0]  adder_result_ex_i,    // address computed in ALU          -> from ID/EX</pre>
<pre style="margin:0; padding:0 ">  39: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  40:     output logic         addr_incr_req_o,      // request address increment for</pre>
<pre style="margin:0; padding:0 ">  41:                                                // misaligned accesses              -> to ID/EX</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  42:     output logic [31:0]  addr_last_o,          // address of last transaction      -> to controller</pre>
<pre style="margin:0; padding:0 ">  43:                                                // -> mtval</pre>
<pre style="margin:0; padding:0 ">  44:                                                // -> AGU for misaligned accesses</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  45:     output logic         data_valid_o,         // LSU has completed transaction    -> to ID/EX</pre>
<pre style="margin:0; padding:0 ">  46: </pre>
<pre style="margin:0; padding:0 ">  47:     // exception signals</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  48:     output logic         load_err_o,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  49:     output logic         store_err_o,</pre>
<pre style="margin:0; padding:0 ">  50: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  51:     output logic         busy_o</pre>
<pre style="margin:0; padding:0 ">  52: );</pre>
<pre style="margin:0; padding:0 ">  53: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  54:   logic [31:0]  data_addr;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  55:   logic [31:0]  data_addr_w_aligned;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  56:   logic [31:0]  addr_last_q;</pre>
<pre style="margin:0; padding:0 ">  57: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  58:   logic         addr_update;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  59:   logic         ctrl_update;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  60:   logic         rdata_update;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  61:   logic [31:8]  rdata_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  62:   logic [1:0]   rdata_offset_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  63:   logic [1:0]   data_type_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  64:   logic         data_sign_ext_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  65:   logic         data_we_q;</pre>
<pre style="margin:0; padding:0 ">  66: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  67:   logic [1:0]   data_offset;   // mux control for data to be written to memory</pre>
<pre style="margin:0; padding:0 ">  68: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  69:   logic [3:0]   data_be;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  70:   logic [31:0]  data_wdata;</pre>
<pre style="margin:0; padding:0 ">  71: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  72:   logic [31:0]  data_rdata_ext;</pre>
<pre style="margin:0; padding:0 ">  73: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  74:   logic [31:0]  rdata_w_ext; // word realignment for misaligned loads</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  75:   logic [31:0]  rdata_h_ext; // sign extension for half words</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  76:   logic [31:0]  rdata_b_ext; // sign extension for bytes</pre>
<pre style="margin:0; padding:0 ">  77: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  78:   logic         split_misaligned_access;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  79:   logic         handle_misaligned_q, handle_misaligned_d; // high after receiving grant for first</pre>
<pre style="margin:0; padding:0 ">  80:                                                           // part of a misaligned access</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  81:   logic         pmp_err_q, pmp_err_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  82:   logic         lsu_err_q, lsu_err_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  83:   logic         data_or_pmp_err;</pre>
<pre style="margin:0; padding:0 ">  84: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  85:   typedef enum logic [2:0]  {</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  86:     IDLE, WAIT_GNT_MIS, WAIT_RVALID_MIS, WAIT_GNT, WAIT_RVALID,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  87:     WAIT_RVALID_DONE</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  88:   } ls_fsm_e;</pre>
<pre style="margin:0; padding:0 ">  89: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  90:   ls_fsm_e ls_fsm_cs, ls_fsm_ns;</pre>
<pre style="margin:0; padding:0 ">  91: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  92:   assign data_addr   = adder_result_ex_i;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  93:   assign data_offset = data_addr[1:0];</pre>
<pre style="margin:0; padding:0 ">  94: </pre>
<pre style="margin:0; padding:0 ">  95:   ///////////////////</pre>
<pre style="margin:0; padding:0 ">  96:   // BE generation //</pre>
<pre style="margin:0; padding:0 ">  97:   ///////////////////</pre>
<pre style="margin:0; padding:0 ">  98: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 ">  99:   always_comb begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 100:     unique case (data_type_ex_i) // Data type 00 Word, 01 Half word, 11,10 byte</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 101:       2'b00: begin // Writing a word</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 102:         if (!handle_misaligned_q) begin // first part of potentially misaligned transaction</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 103:           unique case (data_offset)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 104:             2'b00:   data_be = 4'b1111;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 105:             2'b01:   data_be = 4'b1110;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 106:             2'b10:   data_be = 4'b1100;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 107:             2'b11:   data_be = 4'b1000;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 108:             default: data_be = 4'b1111;</pre>
<pre style="margin:0; padding:0 "> 109:           endcase // case (data_offset)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 110:         end else begin // second part of misaligned transaction</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 111:           unique case (data_offset)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 112:             2'b00:   data_be = 4'b0000; // this is not used, but included for completeness</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 113:             2'b01:   data_be = 4'b0001;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 114:             2'b10:   data_be = 4'b0011;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 115:             2'b11:   data_be = 4'b0111;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 116:             default: data_be = 4'b1111;</pre>
<pre style="margin:0; padding:0 "> 117:           endcase // case (data_offset)</pre>
<pre style="margin:0; padding:0 "> 118:         end</pre>
<pre style="margin:0; padding:0 "> 119:       end</pre>
<pre style="margin:0; padding:0 "> 120: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 121:       2'b01: begin // Writing a half word</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 122:         if (!handle_misaligned_q) begin // first part of potentially misaligned transaction</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 123:           unique case (data_offset)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 124:             2'b00:   data_be = 4'b0011;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 125:             2'b01:   data_be = 4'b0110;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 126:             2'b10:   data_be = 4'b1100;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 127:             2'b11:   data_be = 4'b1000;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 128:             default: data_be = 4'b1111;</pre>
<pre style="margin:0; padding:0 "> 129:           endcase // case (data_offset)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 130:         end else begin // second part of misaligned transaction</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 131:           data_be = 4'b0001;</pre>
<pre style="margin:0; padding:0 "> 132:         end</pre>
<pre style="margin:0; padding:0 "> 133:       end</pre>
<pre style="margin:0; padding:0 "> 134: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 135:       2'b10,</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 136:       2'b11: begin // Writing a byte</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 137:         unique case (data_offset)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 138:           2'b00:   data_be = 4'b0001;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 139:           2'b01:   data_be = 4'b0010;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 140:           2'b10:   data_be = 4'b0100;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 141:           2'b11:   data_be = 4'b1000;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 142:           default: data_be = 4'b1111;</pre>
<pre style="margin:0; padding:0 "> 143:         endcase // case (data_offset)</pre>
<pre style="margin:0; padding:0 "> 144:       end</pre>
<pre style="margin:0; padding:0 "> 145: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 146:       default:     data_be = 4'b1111;</pre>
<pre style="margin:0; padding:0 "> 147:     endcase // case (data_type_ex_i)</pre>
<pre style="margin:0; padding:0 "> 148:   end</pre>
<pre style="margin:0; padding:0 "> 149: </pre>
<pre style="margin:0; padding:0 "> 150:   /////////////////////</pre>
<pre style="margin:0; padding:0 "> 151:   // WData alignment //</pre>
<pre style="margin:0; padding:0 "> 152:   /////////////////////</pre>
<pre style="margin:0; padding:0 "> 153: </pre>
<pre style="margin:0; padding:0 "> 154:   // prepare data to be written to the memory</pre>
<pre style="margin:0; padding:0 "> 155:   // we handle misaligned accesses, half word and byte accesses here</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 156:   always_comb begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 157:     unique case (data_offset)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 158:       2'b00:   data_wdata =  data_wdata_ex_i[31:0];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 159:       2'b01:   data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 160:       2'b10:   data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 161:       2'b11:   data_wdata = {data_wdata_ex_i[ 7:0], data_wdata_ex_i[31: 8]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 162:       default: data_wdata =  data_wdata_ex_i[31:0];</pre>
<pre style="margin:0; padding:0 "> 163:     endcase // case (data_offset)</pre>
<pre style="margin:0; padding:0 "> 164:   end</pre>
<pre style="margin:0; padding:0 "> 165: </pre>
<pre style="margin:0; padding:0 "> 166:   /////////////////////</pre>
<pre style="margin:0; padding:0 "> 167:   // RData alignment //</pre>
<pre style="margin:0; padding:0 "> 168:   /////////////////////</pre>
<pre style="margin:0; padding:0 "> 169: </pre>
<pre style="margin:0; padding:0 "> 170:   // register for unaligned rdata</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 171:   always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 172:     if (!rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 173:       rdata_q <= '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 174:     end else if (rdata_update) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 175:       rdata_q <= data_rdata_i[31:8];</pre>
<pre style="margin:0; padding:0 "> 176:     end</pre>
<pre style="margin:0; padding:0 "> 177:   end</pre>
<pre style="margin:0; padding:0 "> 178: </pre>
<pre style="margin:0; padding:0 "> 179:   // registers for transaction control</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 180:   always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 181:     if (!rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 182:       rdata_offset_q  <= 2'h0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 183:       data_type_q     <= 2'h0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 184:       data_sign_ext_q <= 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 185:       data_we_q       <= 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 186:     end else if (ctrl_update) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 187:       rdata_offset_q  <= data_offset;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 188:       data_type_q     <= data_type_ex_i;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 189:       data_sign_ext_q <= data_sign_ext_ex_i;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 190:       data_we_q       <= data_we_ex_i;</pre>
<pre style="margin:0; padding:0 "> 191:     end</pre>
<pre style="margin:0; padding:0 "> 192:   end</pre>
<pre style="margin:0; padding:0 "> 193: </pre>
<pre style="margin:0; padding:0 "> 194:   // Store last address for mtval + AGU for misaligned transactions.</pre>
<pre style="margin:0; padding:0 "> 195:   // Do not update in case of errors, mtval needs the (first) failing address</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 196:   always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 197:     if (!rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 198:       addr_last_q <= '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 199:     end else if (addr_update) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 200:       addr_last_q <= data_addr;</pre>
<pre style="margin:0; padding:0 "> 201:     end</pre>
<pre style="margin:0; padding:0 "> 202:   end</pre>
<pre style="margin:0; padding:0 "> 203: </pre>
<pre style="margin:0; padding:0 "> 204:   // take care of misaligned words</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 205:   always_comb begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 206:     unique case (rdata_offset_q)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 207:       2'b00:   rdata_w_ext =  data_rdata_i[31:0];</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 208:       2'b01:   rdata_w_ext = {data_rdata_i[ 7:0], rdata_q[31:8]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 209:       2'b10:   rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 210:       2'b11:   rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 211:       default: rdata_w_ext =  data_rdata_i[31:0];</pre>
<pre style="margin:0; padding:0 "> 212:     endcase</pre>
<pre style="margin:0; padding:0 "> 213:   end</pre>
<pre style="margin:0; padding:0 "> 214: </pre>
<pre style="margin:0; padding:0 "> 215:   ////////////////////</pre>
<pre style="margin:0; padding:0 "> 216:   // Sign extension //</pre>
<pre style="margin:0; padding:0 "> 217:   ////////////////////</pre>
<pre style="margin:0; padding:0 "> 218: </pre>
<pre style="margin:0; padding:0 "> 219:   // sign extension for half words</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 220:   always_comb begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 221:     unique case (rdata_offset_q)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 222:       2'b00: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 223:         if (!data_sign_ext_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 224:           rdata_h_ext = {16'h0000, data_rdata_i[15:0]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 225:         end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 226:           rdata_h_ext = {{16{data_rdata_i[15]}}, data_rdata_i[15:0]};</pre>
<pre style="margin:0; padding:0 "> 227:         end</pre>
<pre style="margin:0; padding:0 "> 228:       end</pre>
<pre style="margin:0; padding:0 "> 229: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 230:       2'b01: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 231:         if (!data_sign_ext_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 232:           rdata_h_ext = {16'h0000, data_rdata_i[23:8]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 233:         end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 234:           rdata_h_ext = {{16{data_rdata_i[23]}}, data_rdata_i[23:8]};</pre>
<pre style="margin:0; padding:0 "> 235:         end</pre>
<pre style="margin:0; padding:0 "> 236:       end</pre>
<pre style="margin:0; padding:0 "> 237: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 238:       2'b10: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 239:         if (!data_sign_ext_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 240:           rdata_h_ext = {16'h0000, data_rdata_i[31:16]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 241:         end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 242:           rdata_h_ext = {{16{data_rdata_i[31]}}, data_rdata_i[31:16]};</pre>
<pre style="margin:0; padding:0 "> 243:         end</pre>
<pre style="margin:0; padding:0 "> 244:       end</pre>
<pre style="margin:0; padding:0 "> 245: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 246:       2'b11: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 247:         if (!data_sign_ext_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 248:           rdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 249:         end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 250:           rdata_h_ext = {{16{data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};</pre>
<pre style="margin:0; padding:0 "> 251:         end</pre>
<pre style="margin:0; padding:0 "> 252:       end</pre>
<pre style="margin:0; padding:0 "> 253: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 254:       default: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};</pre>
<pre style="margin:0; padding:0 "> 255:     endcase // case (rdata_offset_q)</pre>
<pre style="margin:0; padding:0 "> 256:   end</pre>
<pre style="margin:0; padding:0 "> 257: </pre>
<pre style="margin:0; padding:0 "> 258:   // sign extension for bytes</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 259:   always_comb begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 260:     unique case (rdata_offset_q)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 261:       2'b00: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 262:         if (!data_sign_ext_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 263:           rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 264:         end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 265:           rdata_b_ext = {{24{data_rdata_i[7]}}, data_rdata_i[7:0]};</pre>
<pre style="margin:0; padding:0 "> 266:         end</pre>
<pre style="margin:0; padding:0 "> 267:       end</pre>
<pre style="margin:0; padding:0 "> 268: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 269:       2'b01: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 270:         if (!data_sign_ext_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 271:           rdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 272:         end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 273:           rdata_b_ext = {{24{data_rdata_i[15]}}, data_rdata_i[15:8]};</pre>
<pre style="margin:0; padding:0 "> 274:         end</pre>
<pre style="margin:0; padding:0 "> 275:       end</pre>
<pre style="margin:0; padding:0 "> 276: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 277:       2'b10: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 278:         if (!data_sign_ext_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 279:           rdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 280:         end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 281:           rdata_b_ext = {{24{data_rdata_i[23]}}, data_rdata_i[23:16]};</pre>
<pre style="margin:0; padding:0 "> 282:         end</pre>
<pre style="margin:0; padding:0 "> 283:       end</pre>
<pre style="margin:0; padding:0 "> 284: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 285:       2'b11: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 286:         if (!data_sign_ext_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 287:           rdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 288:         end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 289:           rdata_b_ext = {{24{data_rdata_i[31]}}, data_rdata_i[31:24]};</pre>
<pre style="margin:0; padding:0 "> 290:         end</pre>
<pre style="margin:0; padding:0 "> 291:       end</pre>
<pre style="margin:0; padding:0 "> 292: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 293:       default: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};</pre>
<pre style="margin:0; padding:0 "> 294:     endcase // case (rdata_offset_q)</pre>
<pre style="margin:0; padding:0 "> 295:   end</pre>
<pre style="margin:0; padding:0 "> 296: </pre>
<pre style="margin:0; padding:0 "> 297:   // select word, half word or byte sign extended version</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 298:   always_comb begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 299:     unique case (data_type_q)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 300:       2'b00:       data_rdata_ext = rdata_w_ext;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 301:       2'b01:       data_rdata_ext = rdata_h_ext;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 302:       2'b10,2'b11: data_rdata_ext = rdata_b_ext;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 303:       default:     data_rdata_ext = rdata_w_ext;</pre>
<pre style="margin:0; padding:0 "> 304:     endcase // case (data_type_q)</pre>
<pre style="margin:0; padding:0 "> 305:   end</pre>
<pre style="margin:0; padding:0 "> 306: </pre>
<pre style="margin:0; padding:0 "> 307:   /////////////</pre>
<pre style="margin:0; padding:0 "> 308:   // LSU FSM //</pre>
<pre style="margin:0; padding:0 "> 309:   /////////////</pre>
<pre style="margin:0; padding:0 "> 310: </pre>
<pre style="margin:0; padding:0 "> 311:   // check for misaligned accesses that need to be split into two word-aligned accesses</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 312:   assign split_misaligned_access =</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 313:       ((data_type_ex_i == 2'b00) && (data_offset != 2'b00)) || // misaligned word access</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 314:       ((data_type_ex_i == 2'b01) && (data_offset == 2'b11));   // misaligned half-word access</pre>
<pre style="margin:0; padding:0 "> 315: </pre>
<pre style="margin:0; padding:0 "> 316:   // FSM</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 317:   always_comb begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 318:     ls_fsm_ns       = ls_fsm_cs;</pre>
<pre style="margin:0; padding:0 "> 319: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 320:     data_req_o          = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 321:     data_valid_o        = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 322:     addr_incr_req_o     = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 323:     handle_misaligned_d = handle_misaligned_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 324:     data_or_pmp_err     = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 325:     pmp_err_d           = pmp_err_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 326:     lsu_err_d           = lsu_err_q;</pre>
<pre style="margin:0; padding:0 "> 327: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 328:     addr_update         = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 329:     ctrl_update         = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 330:     rdata_update        = 1'b0;</pre>
<pre style="margin:0; padding:0 "> 331: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 332:     unique case (ls_fsm_cs)</pre>
<pre style="margin:0; padding:0 "> 333: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 334:       IDLE: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 335:         if (data_req_ex_i) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 336:           data_req_o = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 337:           pmp_err_d  = data_pmp_err_i;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 338:           lsu_err_d  = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 339:           if (data_gnt_i) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 340:             ctrl_update         = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 341:             addr_update         = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 342:             handle_misaligned_d = split_misaligned_access;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 343:             ls_fsm_ns           = split_misaligned_access ? WAIT_RVALID_MIS : WAIT_RVALID;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 344:           end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 345:             ls_fsm_ns           = split_misaligned_access ? WAIT_GNT_MIS    : WAIT_GNT;</pre>
<pre style="margin:0; padding:0 "> 346:           end</pre>
<pre style="margin:0; padding:0 "> 347:         end</pre>
<pre style="margin:0; padding:0 "> 348:       end</pre>
<pre style="margin:0; padding:0 "> 349: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 350:       WAIT_GNT_MIS: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 351:         data_req_o = 1'b1;</pre>
<pre style="margin:0; padding:0 "> 352:         // data_pmp_err_i is valid during the address phase of a request. An error will block the</pre>
<pre style="margin:0; padding:0 "> 353:         // external request and so a data_gnt_i might never be signalled. The registered version</pre>
<pre style="margin:0; padding:0 "> 354:         // pmp_err_q is only updated for new address phases and so can be used in WAIT_GNT* and</pre>
<pre style="margin:0; padding:0 "> 355:         // WAIT_RVALID* states</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 356:         if (data_gnt_i || pmp_err_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 357:           addr_update         = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 358:           ctrl_update         = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 359:           handle_misaligned_d = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 360:           ls_fsm_ns           = WAIT_RVALID_MIS;</pre>
<pre style="margin:0; padding:0 "> 361:         end</pre>
<pre style="margin:0; padding:0 "> 362:       end</pre>
<pre style="margin:0; padding:0 "> 363: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 364:       WAIT_RVALID_MIS: begin</pre>
<pre style="margin:0; padding:0 "> 365:         // push out second request</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 366:         data_req_o = 1'b1;</pre>
<pre style="margin:0; padding:0 "> 367:         // tell ID/EX stage to update the address</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 368:         addr_incr_req_o = 1'b1;</pre>
<pre style="margin:0; padding:0 "> 369: </pre>
<pre style="margin:0; padding:0 "> 370:         // first part rvalid is received, or gets a PMP error</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 371:         if (data_rvalid_i || pmp_err_q) begin</pre>
<pre style="margin:0; padding:0 "> 372:           // Update the PMP error for the second part</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 373:           pmp_err_d = data_pmp_err_i;</pre>
<pre style="margin:0; padding:0 "> 374:           // Record the error status of the first part</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 375:           lsu_err_d = data_err_i | pmp_err_q;</pre>
<pre style="margin:0; padding:0 "> 376:           // Capture the first rdata for loads</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 377:           rdata_update = ~data_we_q;</pre>
<pre style="margin:0; padding:0 "> 378:           // If already granted, wait for second rvalid</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 379:           ls_fsm_ns = data_gnt_i ? WAIT_RVALID : WAIT_GNT;</pre>
<pre style="margin:0; padding:0 "> 380:           // Update the address for the second part, if no error</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 381:           addr_update = data_gnt_i & ~(data_err_i | pmp_err_q);</pre>
<pre style="margin:0; padding:0 "> 382: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 383:         end else begin</pre>
<pre style="margin:0; padding:0 "> 384:           // first part rvalid is NOT received</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 385:           if (data_gnt_i) begin</pre>
<pre style="margin:0; padding:0 "> 386:             // second grant is received</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 387:             ls_fsm_ns = WAIT_RVALID_DONE;</pre>
<pre style="margin:0; padding:0 "> 388:           end</pre>
<pre style="margin:0; padding:0 "> 389:         end</pre>
<pre style="margin:0; padding:0 "> 390:       end</pre>
<pre style="margin:0; padding:0 "> 391: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 392:       WAIT_GNT: begin</pre>
<pre style="margin:0; padding:0 "> 393:         // tell ID/EX stage to update the address</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 394:         addr_incr_req_o = handle_misaligned_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 395:         data_req_o      = 1'b1;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 396:         if (data_gnt_i || pmp_err_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 397:           ctrl_update = 1'b1;</pre>
<pre style="margin:0; padding:0 "> 398:           // Update the address, unless there was an error</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 399:           addr_update = ~lsu_err_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 400:           ls_fsm_ns   = WAIT_RVALID;</pre>
<pre style="margin:0; padding:0 "> 401:         end</pre>
<pre style="margin:0; padding:0 "> 402:       end</pre>
<pre style="margin:0; padding:0 "> 403: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 404:       WAIT_RVALID: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 405:         if (data_rvalid_i || pmp_err_q) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 406:           data_valid_o        = 1'b1;</pre>
<pre style="margin:0; padding:0 "> 407:           // Data error from either part</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 408:           data_or_pmp_err     = lsu_err_q | data_err_i | pmp_err_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 409:           handle_misaligned_d = 1'b0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 410:           ls_fsm_ns           = IDLE;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 411:         end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 412:           ls_fsm_ns           = WAIT_RVALID;</pre>
<pre style="margin:0; padding:0 "> 413:         end</pre>
<pre style="margin:0; padding:0 "> 414:       end</pre>
<pre style="margin:0; padding:0 "> 415: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 416:       WAIT_RVALID_DONE: begin</pre>
<pre style="margin:0; padding:0 "> 417:         // tell ID/EX stage to update the address (to make sure the</pre>
<pre style="margin:0; padding:0 "> 418:         // second address can be captured correctly for mtval and PMP checking)</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 419:         addr_incr_req_o = 1'b1;</pre>
<pre style="margin:0; padding:0 "> 420:         // Wait for the first rvalid, second request is already granted</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 421:         if (data_rvalid_i) begin</pre>
<pre style="margin:0; padding:0 "> 422:           // Update the pmp error for the second part</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 423:           pmp_err_d = data_pmp_err_i;</pre>
<pre style="margin:0; padding:0 "> 424:           // The first part cannot see a PMP error in this state</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 425:           lsu_err_d = data_err_i;</pre>
<pre style="margin:0; padding:0 "> 426:           // Now we can update the address for the second part if no error</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 427:           addr_update = ~data_err_i;</pre>
<pre style="margin:0; padding:0 "> 428:           // Capture the first rdata for loads</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 429:           rdata_update = ~data_we_q;</pre>
<pre style="margin:0; padding:0 "> 430:           // Wait for second rvalid</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 431:           ls_fsm_ns = WAIT_RVALID;</pre>
<pre style="margin:0; padding:0 "> 432:         end</pre>
<pre style="margin:0; padding:0 "> 433:       end</pre>
<pre style="margin:0; padding:0 "> 434: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 435:       default: begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 436:         ls_fsm_ns = IDLE;</pre>
<pre style="margin:0; padding:0 "> 437:       end</pre>
<pre style="margin:0; padding:0 "> 438:     endcase</pre>
<pre style="margin:0; padding:0 "> 439:   end</pre>
<pre style="margin:0; padding:0 "> 440: </pre>
<pre style="margin:0; padding:0 "> 441:   // registers for FSM</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 442:   always_ff @(posedge clk_i or negedge rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 443:     if (!rst_ni) begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 444:       ls_fsm_cs           <= IDLE;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 445:       handle_misaligned_q <= '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 446:       pmp_err_q           <= '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 447:       lsu_err_q           <= '0;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 448:     end else begin</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 449:       ls_fsm_cs           <= ls_fsm_ns;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 450:       handle_misaligned_q <= handle_misaligned_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 451:       pmp_err_q           <= pmp_err_d;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 452:       lsu_err_q           <= lsu_err_d;</pre>
<pre style="margin:0; padding:0 "> 453:     end</pre>
<pre style="margin:0; padding:0 "> 454:   end</pre>
<pre style="margin:0; padding:0 "> 455: </pre>
<pre style="margin:0; padding:0 "> 456:   /////////////</pre>
<pre style="margin:0; padding:0 "> 457:   // Outputs //</pre>
<pre style="margin:0; padding:0 "> 458:   /////////////</pre>
<pre style="margin:0; padding:0 "> 459: </pre>
<pre style="margin:0; padding:0 "> 460:   // output to register file</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 461:   assign data_rdata_ex_o = data_rdata_ext;</pre>
<pre style="margin:0; padding:0 "> 462: </pre>
<pre style="margin:0; padding:0 "> 463:   // output data address must be word aligned</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 464:   assign data_addr_w_aligned = {data_addr[31:2], 2'b00};</pre>
<pre style="margin:0; padding:0 "> 465: </pre>
<pre style="margin:0; padding:0 "> 466:   // output to data interface</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 467:   assign data_addr_o   = data_addr_w_aligned;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 468:   assign data_wdata_o  = data_wdata;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 469:   assign data_we_o     = data_we_ex_i;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 470:   assign data_be_o     = data_be;</pre>
<pre style="margin:0; padding:0 "> 471: </pre>
<pre style="margin:0; padding:0 "> 472:   // output to ID stage: mtval + AGU for misaligned transactions</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 473:   assign addr_last_o   = addr_last_q;</pre>
<pre style="margin:0; padding:0 "> 474: </pre>
<pre style="margin:0; padding:0 "> 475:   // Signal a load or store error depending on the transaction type outstanding</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 476:   assign load_err_o    = data_or_pmp_err & ~data_we_q;</pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 477:   assign store_err_o   = data_or_pmp_err &  data_we_q;</pre>
<pre style="margin:0; padding:0 "> 478: </pre>
<pre style="background-color: #C0C0C0; margin:0; padding:0 "> 479:   assign busy_o = (ls_fsm_cs != IDLE);</pre>
<pre style="margin:0; padding:0 "> 480: </pre>
<pre style="margin:0; padding:0 "> 481:   ////////////////</pre>
<pre style="margin:0; padding:0 "> 482:   // Assertions //</pre>
<pre style="margin:0; padding:0 "> 483:   ////////////////</pre>
<pre style="margin:0; padding:0 "> 484: </pre>
<pre style="margin:0; padding:0 "> 485:   // Selectors must be known/valid.</pre>
<pre style="margin:0; padding:0 "> 486:   `ASSERT_KNOWN(IbexDataTypeKnown, data_type_ex_i, clk_i, !rst_ni)</pre>
<pre style="margin:0; padding:0 "> 487:   `ASSERT_KNOWN(IbexDataOffsetKnown, data_offset, clk_i, !rst_ni)</pre>
<pre style="margin:0; padding:0 "> 488:   `ASSERT_KNOWN(IbexRDataOffsetQKnown, rdata_offset_q, clk_i, !rst_ni)</pre>
<pre style="margin:0; padding:0 "> 489:   `ASSERT_KNOWN(IbexDataTypeQKnown, data_type_q, clk_i, !rst_ni)</pre>
<pre style="margin:0; padding:0 "> 490:   `ASSERT(IbexLsuStateValid, ls_fsm_cs inside {</pre>
<pre style="margin:0; padding:0 "> 491:       IDLE, WAIT_GNT_MIS, WAIT_RVALID_MIS, WAIT_GNT, WAIT_RVALID,</pre>
<pre style="margin:0; padding:0 "> 492:       WAIT_RVALID_DONE</pre>
<pre style="margin:0; padding:0 "> 493:       }, clk_i, !rst_ni)</pre>
<pre style="margin:0; padding:0 "> 494: </pre>
<pre style="margin:0; padding:0 "> 495:   // There must not be an rvalid unless the FSM is handlling it.</pre>
<pre style="margin:0; padding:0 "> 496:   `ASSERT(IbexRvalidNotHandled, data_rvalid_i |-> (</pre>
<pre style="margin:0; padding:0 "> 497:       (ls_fsm_cs == WAIT_RVALID) ||</pre>
<pre style="margin:0; padding:0 "> 498:       (ls_fsm_cs == WAIT_RVALID_MIS) ||</pre>
<pre style="margin:0; padding:0 "> 499:       (ls_fsm_cs == WAIT_RVALID_DONE)</pre>
<pre style="margin:0; padding:0 "> 500:       ), clk_i, !rst_ni)</pre>
<pre style="margin:0; padding:0 "> 501: </pre>
<pre style="margin:0; padding:0 "> 502:   // Errors must only be sent together with rvalid.</pre>
<pre style="margin:0; padding:0 "> 503:   `ASSERT(IbexDataErrWithoutRvalid, data_err_i |-> data_rvalid_i, clk_i, !rst_ni)</pre>
<pre style="margin:0; padding:0 "> 504: </pre>
<pre style="margin:0; padding:0 "> 505:   // Address must not contain X when request is sent.</pre>
<pre style="margin:0; padding:0 "> 506:   `ASSERT(IbexDataAddrUnknown, data_req_o |-> !$isunknown(data_addr_o), clk_i, !rst_ni)</pre>
<pre style="margin:0; padding:0 "> 507: </pre>
<pre style="margin:0; padding:0 "> 508:   // Address must be word aligned when request is sent.</pre>
<pre style="margin:0; padding:0 "> 509:   `ASSERT(IbexDataAddrUnaligned, data_req_o |-> (data_addr_o[1:0] == 2'b00), clk_i, !rst_ni)</pre>
<pre style="margin:0; padding:0 "> 510: </pre>
<pre style="margin:0; padding:0 "> 511: endmodule</pre>
<pre style="margin:0; padding:0 "> 512: </pre>
</body>
</html>
